<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeCAD: Data::IndexedName Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FreeCAD
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../df/df7/namespaceData.html">Data</a></li><li class="navelem"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../da/d6b/classData_1_1IndexedName-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Data::IndexedName Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a23b1413f246de28d21ff94339881280a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html#a23b1413f246de28d21ff94339881280a">IndexedName</a> (const char *name=nullptr, int _index=0)</td></tr>
<tr class="separator:a23b1413f246de28d21ff94339881280a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d15ab771564ea758c5bde737547922"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html#a69d15ab771564ea758c5bde737547922">IndexedName</a> (const char *name, const std::vector&lt; const char * &gt; &amp;allowedTypeNames, bool allowOthers=true)</td></tr>
<tr class="separator:a69d15ab771564ea758c5bde737547922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5598845a61407df0f9b8cca94b465755"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html#a5598845a61407df0f9b8cca94b465755">IndexedName</a> (const QByteArray &amp;data)</td></tr>
<tr class="separator:a5598845a61407df0f9b8cca94b465755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7845a409e2c29bba1ba469c9bf0cbd3b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html#a7845a409e2c29bba1ba469c9bf0cbd3b">appendToStringBuffer</a> (std::string &amp;buffer) const</td></tr>
<tr class="separator:a7845a409e2c29bba1ba469c9bf0cbd3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334c76c8f2ac9ea331796454310ca9ff"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html#a334c76c8f2ac9ea331796454310ca9ff">toString</a> () const</td></tr>
<tr class="separator:a334c76c8f2ac9ea331796454310ca9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5293c470430944c3c19d0992d751a39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html#ad5293c470430944c3c19d0992d751a39">operator==</a> (const <a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a> &amp;other) const</td></tr>
<tr class="memdesc:ad5293c470430944c3c19d0992d751a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">True only if both the name and index compare exactly equal.  <a href="../../d8/deb/classData_1_1IndexedName.html#ad5293c470430944c3c19d0992d751a39">More...</a><br /></td></tr>
<tr class="separator:ad5293c470430944c3c19d0992d751a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7102294c9bc9fe204a27b7bd251addcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html#a7102294c9bc9fe204a27b7bd251addcc">operator+=</a> (int offset)</td></tr>
<tr class="memdesc:a7102294c9bc9fe204a27b7bd251addcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the index by the given offset. Does not affect the text part of the name.  <a href="../../d8/deb/classData_1_1IndexedName.html#a7102294c9bc9fe204a27b7bd251addcc">More...</a><br /></td></tr>
<tr class="separator:a7102294c9bc9fe204a27b7bd251addcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09194af5509563fa3e8e67b2234e4c3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html#a09194af5509563fa3e8e67b2234e4c3b">operator++</a> ()</td></tr>
<tr class="memdesc:a09194af5509563fa3e8e67b2234e4c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-increment operator: increases the index of this element by one.  <a href="../../d8/deb/classData_1_1IndexedName.html#a09194af5509563fa3e8e67b2234e4c3b">More...</a><br /></td></tr>
<tr class="separator:a09194af5509563fa3e8e67b2234e4c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f6380686ab2e0e5549efe49d2a3b41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html#a37f6380686ab2e0e5549efe49d2a3b41">operator--</a> ()</td></tr>
<tr class="separator:a37f6380686ab2e0e5549efe49d2a3b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e1caea9d8f7c81e39a62415ef0916d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html#a11e1caea9d8f7c81e39a62415ef0916d">operator!=</a> (const <a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a> &amp;other) const</td></tr>
<tr class="memdesc:a11e1caea9d8f7c81e39a62415ef0916d"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if either the name or the index compare not equal.  <a href="../../d8/deb/classData_1_1IndexedName.html#a11e1caea9d8f7c81e39a62415ef0916d">More...</a><br /></td></tr>
<tr class="separator:a11e1caea9d8f7c81e39a62415ef0916d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c739eb8f3e84adeea3cf29b3746996"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html#a50c739eb8f3e84adeea3cf29b3746996">compare</a> (const <a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a> &amp;other) const</td></tr>
<tr class="memdesc:a50c739eb8f3e84adeea3cf29b3746996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to C++20's operator &lt;=&gt;  <a href="../../d8/deb/classData_1_1IndexedName.html#a50c739eb8f3e84adeea3cf29b3746996">More...</a><br /></td></tr>
<tr class="separator:a50c739eb8f3e84adeea3cf29b3746996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73fe1b05f4b8d4994fcdc3105104895"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html#af73fe1b05f4b8d4994fcdc3105104895">operator&lt;</a> (const <a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a> &amp;other) const</td></tr>
<tr class="separator:af73fe1b05f4b8d4994fcdc3105104895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace536174d010523d1c89f945b664a48b"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html#ace536174d010523d1c89f945b664a48b">operator[]</a> (int input) const</td></tr>
<tr class="separator:ace536174d010523d1c89f945b664a48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f8692618e248c879dd673f35dd15dc"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html#ac8f8692618e248c879dd673f35dd15dc">getType</a> () const</td></tr>
<tr class="memdesc:ac8f8692618e248c879dd673f35dd15dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to text part of the name - does NOT make a copy, returns direct memory access.  <a href="../../d8/deb/classData_1_1IndexedName.html#ac8f8692618e248c879dd673f35dd15dc">More...</a><br /></td></tr>
<tr class="separator:ac8f8692618e248c879dd673f35dd15dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7749c28fe51860d975c3b41508e43da6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html#a7749c28fe51860d975c3b41508e43da6">getIndex</a> () const</td></tr>
<tr class="memdesc:a7749c28fe51860d975c3b41508e43da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the numerical part of the name.  <a href="../../d8/deb/classData_1_1IndexedName.html#a7749c28fe51860d975c3b41508e43da6">More...</a><br /></td></tr>
<tr class="separator:a7749c28fe51860d975c3b41508e43da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca606e1c3099edacfc036e1e0860d47f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html#aca606e1c3099edacfc036e1e0860d47f">setIndex</a> (int input)</td></tr>
<tr class="separator:aca606e1c3099edacfc036e1e0860d47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b5b1fc769c4132f281d8491167e90e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html#a44b5b1fc769c4132f281d8491167e90e">isNull</a> () const</td></tr>
<tr class="memdesc:a44b5b1fc769c4132f281d8491167e90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A name is considered "null" if its text component is an empty string.  <a href="../../d8/deb/classData_1_1IndexedName.html#a44b5b1fc769c4132f281d8491167e90e">More...</a><br /></td></tr>
<tr class="separator:a44b5b1fc769c4132f281d8491167e90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d54f3ff81ff4956d092f103a4d9b1f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html#a3d54f3ff81ff4956d092f103a4d9b1f2">operator bool</a> () const</td></tr>
<tr class="separator:a3d54f3ff81ff4956d092f103a4d9b1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afd864f4784a392157c254d97a36d425a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html#afd864f4784a392157c254d97a36d425a">fromConst</a> (const char *name, int index)</td></tr>
<tr class="separator:afd864f4784a392157c254d97a36d425a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a568e25b828f26ecafa56224342f21ebe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html#a568e25b828f26ecafa56224342f21ebe">set</a> (const char *name, int length=-1, const std::vector&lt; const char * &gt; &amp;allowedNames={}, bool allowOthers=true)</td></tr>
<tr class="separator:a568e25b828f26ecafa56224342f21ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a33bf407e2a9279f62af6225a0074def2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html#a33bf407e2a9279f62af6225a0074def2">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a> &amp;indexedName)</td></tr>
<tr class="separator:a33bf407e2a9279f62af6225a0074def2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a> class provides a very memory-efficient data structure to hold a name and an index value, and to perform various comparisons and validations of those values. The name must only consist of upper- and lower-case ASCII characters and the underscore ('_') character. The index must be a positive integer. The string representation of this <a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a> is the name followed by the index, with no spaces between: an <a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a> may be constructed from this string. For example "EDGE1" or "FACE345" might be the names of elements that use an <a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a>. If there is then an "EDGE2", only a pointer to the original stored name "EDGE" is retained.</p>
<p>The memory efficiency of the class comes from re-using the same character storage for names that match, while retaining their differing indices. This is achieved by either using user-provided const char * names (provided as a list of typeNames and presumed to never be deallocated), or by maintaining an internal list of names that have been used before, and can be re-used later. </p>

<p class="definition">Definition at line <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00075">75</a> of file <a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a23b1413f246de28d21ff94339881280a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b1413f246de28d21ff94339881280a">&#9670;&nbsp;</a></span>IndexedName() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Data::IndexedName::IndexedName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct from a name and an optional index. If the name contains an index it is read, but is used as the index <em>only</em> if _index parameter is unset. If the _index parameter is given it overrides any trailing integer in the name. Index must be positive, and name must contain only ASCII letters and the underscore character. If these conditions are not met, name is set to the empty string, and <a class="el" href="../../d8/deb/classData_1_1IndexedName.html#a44b5b1fc769c4132f281d8491167e90e" title="A name is considered &quot;null&quot; if its text component is an empty string.">isNull()</a> will return true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The new name - ASCII letters and underscores only, with optional integer suffix. This memory will be copied into a new internal storage location and need not be persistent. </td></tr>
    <tr><td class="paramname">_index</td><td>The new index - if provided, it overrides any suffix provided by name </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00107">107</a> of file <a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>.</p>

</div>
</div>
<a id="a69d15ab771564ea758c5bde737547922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d15ab771564ea758c5bde737547922">&#9670;&nbsp;</a></span>IndexedName() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Data::IndexedName::IndexedName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const char * &gt; &amp;&#160;</td>
          <td class="paramname"><em>allowedTypeNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowOthers</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an indexed name that is restricted to a list of preset type names. If it appears in that list, only a pointer to the character storage in the list is retained: the memory locations pointed at by the list must never be destroyed once they have been used to create names. If allowOthers is true (the default) then a requested name that is not in the list will be added to a static internal storage table, and its memory then re-used for later objects with the same name. If allowOthers is false, then the name request is rejected, and the name is treated as null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The new name - ASCII letters and underscores only, with optional integer suffix </td></tr>
    <tr><td class="paramname">allowedTypeNames</td><td>A vector of allowed names. Storage locations must persist for the entire run of the program. </td></tr>
    <tr><td class="paramname">allowOthers</td><td>Whether a name not in allowedTypeNames is permitted. If true (the default) then a name not in allowedTypeNames is added to a static internal storage vector so that it can be re-used later without additional memory allocation. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00136">136</a> of file <a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>.</p>

</div>
</div>
<a id="a5598845a61407df0f9b8cca94b465755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5598845a61407df0f9b8cca94b465755">&#9670;&nbsp;</a></span>IndexedName() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Data::IndexedName::IndexedName </td>
          <td>(</td>
          <td class="paramtype">const QByteArray &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct from a QByteArray, but explicitly making a copy of the name on its first occurrence. If this is a name that has already been stored internally, no additional copy is made.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The QByteArray to copy the data from </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00150">150</a> of file <a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7845a409e2c29bba1ba469c9bf0cbd3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7845a409e2c29bba1ba469c9bf0cbd3b">&#9670;&nbsp;</a></span>appendToStringBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* Data::IndexedName::appendToStringBuffer </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given an existing std::string, <em>append</em> this name to it. If index is not zero, this will include the index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A (possibly non-empty) string buffer to append the name to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const char pointer to the name we appended to the buffer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00178">178</a> of file <a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d8/d5a/GeoFeature_8cpp_source.html#l00102">App::GeoFeature::_getElementName()</a>, <a class="el" href="../../d7/d91/PartFeature_8cpp_source.html#l00661">Part::Feature::getElementFromSource()</a>, and <a class="el" href="../../d5/d32/SketchObject_8cpp_source.html#l11382">Sketcher::SketchObject::getElementName()</a>.</p>

</div>
</div>
<a id="a50c739eb8f3e84adeea3cf29b3746996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c739eb8f3e84adeea3cf29b3746996">&#9670;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Data::IndexedName::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to C++20's operator &lt;=&gt; </p>

<p class="definition">Definition at line <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00248">248</a> of file <a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/de8/ArchVRM_8py_source.html#l00459">ArchVRM.Renderer::findPosition()</a>, <a class="el" href="../../da/dd4/MappedElement_8h_source.html#l00089">Data::MappedElement::operator&lt;()</a>, and <a class="el" href="../../de/de8/ArchVRM_8py_source.html#l00481">ArchVRM.Renderer::sort()</a>.</p>

</div>
</div>
<a id="afd864f4784a392157c254d97a36d425a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd864f4784a392157c254d97a36d425a">&#9670;&nbsp;</a></span>fromConst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a> Data::IndexedName::fromConst </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given constant name and an index, re-use the existing memory for the name, not making a copy of it, or scanning any existing storage for it. The name must never become invalid for the lifetime of the object it names. This memory will never be re-used by another object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the object. This memory is NOT copied and must be persistent. </td></tr>
    <tr><td class="paramname">index</td><td>A positive, non-zero integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a> with the given name and index, re-using the existing memory for name </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00164">164</a> of file <a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d5/d32/SketchObject_8cpp_source.html#l00324">Sketcher::SketchObject::buildShape()</a>, <a class="el" href="../../d5/d32/SketchObject_8cpp_source.html#l11476">Sketcher::SketchObject::checkSubName()</a>, <a class="el" href="../../d5/d32/SketchObject_8cpp_source.html#l11646">Sketcher::SketchObject::convertSubName()</a>, <a class="el" href="../../d9/d69/TopoShapeExpansion_8cpp_source.html#l00109">FC_LOG_LEVEL_INIT()</a>, <a class="el" href="../../d5/d32/SketchObject_8cpp_source.html#l11445">Sketcher::SketchObject::getEdge()</a>, <a class="el" href="../../d7/d91/PartFeature_8cpp_source.html#l00661">Part::Feature::getElementFromSource()</a>, <a class="el" href="../../d7/d91/PartFeature_8cpp_source.html#l00176">Part::Feature::getExportElementName()</a>, <a class="el" href="../../d5/d32/SketchObject_8cpp_source.html#l11288">Sketcher::SketchObject::getHigherElements()</a>, <a class="el" href="../../d7/d91/PartFeature_8cpp_source.html#l00790">Part::Feature::getRelatedElements()</a>, <a class="el" href="../../d5/d32/SketchObject_8cpp_source.html#l11162">Sketcher::SketchObject::getSubObject()</a>, <a class="el" href="../../d4/dea/FaceMaker_8cpp_source.html#l00187">Part::FaceMaker::postBuild()</a>, <a class="el" href="../../da/d3e/Feature_8cpp_source.html#l00130">PartDesign::Feature::setMaterialToBodyMaterial()</a>, and <a class="el" href="../../d5/d32/SketchObject_8cpp_source.html#l11579">Sketcher::SketchObject::shapeTypeFromGeoId()</a>.</p>

</div>
</div>
<a id="a7749c28fe51860d975c3b41508e43da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7749c28fe51860d975c3b41508e43da6">&#9670;&nbsp;</a></span>getIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Data::IndexedName::getIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the numerical part of the name. </p>

<p class="definition">Definition at line <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00288">288</a> of file <a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d7/d7a/ElementMap_8cpp_source.html#l01083">Data::ElementMap::addChildElements()</a>, <a class="el" href="../../d5/d32/SketchObject_8cpp_source.html#l11646">Sketcher::SketchObject::convertSubName()</a>, <a class="el" href="../../d7/d7a/ElementMap_8cpp_source.html#l00792">Data::ElementMap::erase()</a>, <a class="el" href="../../d5/d64/App_2FeatureChamfer_8cpp_source.html#l00044">Part::Chamfer::execute()</a>, <a class="el" href="../../d0/d86/App_2FeatureFillet_8cpp_source.html#l00046">Part::Fillet::execute()</a>, <a class="el" href="../../d9/d69/TopoShapeExpansion_8cpp_source.html#l00109">FC_LOG_LEVEL_INIT()</a>, <a class="el" href="../../d7/d7a/ElementMap_8cpp_source.html#l00819">Data::ElementMap::find()</a>, <a class="el" href="../../d7/d7a/ElementMap_8cpp_source.html#l00922">Data::ElementMap::findAll()</a>, <a class="el" href="../../d5/d32/SketchObject_8cpp_source.html#l11610">Sketcher::SketchObject::geoIdFromShapeType()</a>, <a class="el" href="../../d7/d7a/ElementMap_8cpp_source.html#l01298">Data::ElementMap::getAll()</a>, <a class="el" href="../../d2/d2c/StringHasher_8cpp_source.html#l00301">App::StringHasher::getID()</a>, <a class="el" href="../../d5/d32/SketchObject_8cpp_source.html#l11162">Sketcher::SketchObject::getSubObject()</a>, and <a class="el" href="../../d0/d36/TopoShape_8cpp_source.html#l00451">Part::TopoShape::shapeTypeAndIndex()</a>.</p>

</div>
</div>
<a id="ac8f8692618e248c879dd673f35dd15dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f8692618e248c879dd673f35dd15dc">&#9670;&nbsp;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* Data::IndexedName::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to text part of the name - does NOT make a copy, returns direct memory access. </p>

<p class="definition">Definition at line <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00282">282</a> of file <a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d7/d7a/ElementMap_8cpp_source.html#l01083">Data::ElementMap::addChildElements()</a>, <a class="el" href="../../d5/d32/SketchObject_8cpp_source.html#l11646">Sketcher::SketchObject::convertSubName()</a>, <a class="el" href="../../d9/d48/ComplexGeoData_8cpp_source.html#l00374">Data::ComplexGeoData::elementType()</a>, <a class="el" href="../../d7/d7a/ElementMap_8cpp_source.html#l00792">Data::ElementMap::erase()</a>, <a class="el" href="../../d7/d7a/ElementMap_8cpp_source.html#l00819">Data::ElementMap::find()</a>, <a class="el" href="../../d7/d7a/ElementMap_8cpp_source.html#l00922">Data::ElementMap::findAll()</a>, <a class="el" href="../../d5/d32/SketchObject_8cpp_source.html#l11610">Sketcher::SketchObject::geoIdFromShapeType()</a>, <a class="el" href="../../d7/d91/PartFeature_8cpp_source.html#l00176">Part::Feature::getExportElementName()</a>, <a class="el" href="../../d2/d2c/StringHasher_8cpp_source.html#l00301">App::StringHasher::getID()</a>, <a class="el" href="../../d5/d32/SketchObject_8cpp_source.html#l11162">Sketcher::SketchObject::getSubObject()</a>, <a class="el" href="../../d7/d7a/ElementMap_8cpp_source.html#l00548">Data::ElementMap::setElementName()</a>, and <a class="el" href="../../d0/d36/TopoShape_8cpp_source.html#l00451">Part::TopoShape::shapeTypeAndIndex()</a>.</p>

</div>
</div>
<a id="a44b5b1fc769c4132f281d8491167e90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b5b1fc769c4132f281d8491167e90e">&#9670;&nbsp;</a></span>isNull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Data::IndexedName::isNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A name is considered "null" if its text component is an empty string. </p>

<p class="definition">Definition at line <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00306">306</a> of file <a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>.</p>

<p class="reference">References <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00327">Data::ByteArray::ByteArray()</a>, <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00365">Data::ByteArray::bytes</a>, and <a class="el" href="../../dd/d00/opensbp__post_8py_source.html#l00189">Path.Post.scripts.opensbp_post::move()</a>.</p>

</div>
</div>
<a id="a3d54f3ff81ff4956d092f103a4d9b1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d54f3ff81ff4956d092f103a4d9b1f2">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Data::IndexedName::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Boolean conversion provides the opposite of <a class="el" href="../../d8/deb/classData_1_1IndexedName.html#a44b5b1fc769c4132f281d8491167e90e" title="A name is considered &quot;null&quot; if its text component is an empty string.">isNull()</a>, yielding true when the text part of the name is NOT the empty string. </p>

<p class="definition">Definition at line <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00313">313</a> of file <a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>.</p>

</div>
</div>
<a id="a11e1caea9d8f7c81e39a62415ef0916d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e1caea9d8f7c81e39a62415ef0916d">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Data::IndexedName::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if either the name or the index compare not equal. </p>

<p class="definition">Definition at line <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00242">242</a> of file <a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>.</p>

<p class="reference">References <a class="el" href="../../d8/da6/grbl__post_8py_source.html#l00138">Path.Post.scripts.grbl_post::type</a>.</p>

</div>
</div>
<a id="a09194af5509563fa3e8e67b2234e4c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09194af5509563fa3e8e67b2234e4c3b">&#9670;&nbsp;</a></span>operator++()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a>&amp; Data::IndexedName::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pre-increment operator: increases the index of this element by one. </p>

<p class="definition">Definition at line <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00226">226</a> of file <a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>.</p>

<p class="reference">References <a class="el" href="../../d4/d49/ifc__selftest_8py_source.html#l00076">nativeifc.ifc_selftest::compare()</a>.</p>

</div>
</div>
<a id="a7102294c9bc9fe204a27b7bd251addcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7102294c9bc9fe204a27b7bd251addcc">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a>&amp; Data::IndexedName::operator+= </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments the index by the given offset. Does not affect the text part of the name. </p>

<p class="definition">Definition at line <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00218">218</a> of file <a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>.</p>

</div>
</div>
<a id="a37f6380686ab2e0e5549efe49d2a3b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f6380686ab2e0e5549efe49d2a3b41">&#9670;&nbsp;</a></span>operator--()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a>&amp; Data::IndexedName::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pre-decrement operator: decreases the index of this element by one. Must not make the index negative (only checked when compiled in debug mode). </p>

<p class="definition">Definition at line <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00234">234</a> of file <a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>.</p>

</div>
</div>
<a id="af73fe1b05f4b8d4994fcdc3105104895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73fe1b05f4b8d4994fcdc3105104895">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Data::IndexedName::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provided to enable sorting operations: the comparison is first lexicographical for the text element of the names, then numerical for the indices. </p>

<p class="definition">Definition at line <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00265">265</a> of file <a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>.</p>

<p class="reference">References <a class="el" href="../../d8/da6/grbl__post_8py_source.html#l00138">Path.Post.scripts.grbl_post::type</a>.</p>

</div>
</div>
<a id="ad5293c470430944c3c19d0992d751a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5293c470430944c3c19d0992d751a39">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Data::IndexedName::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True only if both the name and index compare exactly equal. </p>

<p class="definition">Definition at line <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00211">211</a> of file <a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>.</p>

</div>
</div>
<a id="ace536174d010523d1c89f945b664a48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace536174d010523d1c89f945b664a48b">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char Data::IndexedName::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allow direct memory access to the individual characters of the text portion of the name. NOTE: input is not range-checked when compiled in release mode. </p>

<p class="definition">Definition at line <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00272">272</a> of file <a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>.</p>

</div>
</div>
<a id="a568e25b828f26ecafa56224342f21ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568e25b828f26ecafa56224342f21ebe">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexedName::set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const char * &gt; &amp;&#160;</td>
          <td class="paramname"><em>allowedNames</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowOthers</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply the <a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a> rules and either store the characters of a new type or a reference to the characters in a type named in types, or stored statically within this function. If len is not set, or set to -1 (the default), then the provided string in name is scanned for its length using strlen (e.g. it must be null-terminated).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The new name. If necessary a copy is made, this char * need not be persistent </td></tr>
    <tr><td class="paramname">length</td><td>The length of name </td></tr>
    <tr><td class="paramname">allowedNames</td><td>A vector of storage locations of allowed names. These storage locations must be persistent for the duration of the program run. </td></tr>
    <tr><td class="paramname">allowOthers</td><td>If true (the default), then if name is not in allowedNames it is allowed, and it is added to internal storage (making a copy of the name if this is its first occurrence). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../db/da9/IndexedName_8cpp_source.html#l00071">71</a> of file <a class="el" href="../../db/da9/IndexedName_8cpp_source.html">IndexedName.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../db/da9/IndexedName_8cpp_source.html#l00050">getIntegerSuffix()</a>, and <a class="el" href="../../db/da9/IndexedName_8cpp_source.html#l00038">isInvalidChar()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d5/d01/gui__trackers_8py_source.html#l00911">draftguitools.gui_trackers.editTracker::move()</a>.</p>

</div>
</div>
<a id="aca606e1c3099edacfc036e1e0860d47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca606e1c3099edacfc036e1e0860d47f">&#9670;&nbsp;</a></span>setIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Data::IndexedName::setIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the numerical part of the name (note that there is no equivalent function to allow changing the text part of the name, which is immutable once created).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The new index. Must be a positive non-zero integer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00297">297</a> of file <a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d7/d7a/ElementMap_8cpp_source.html#l00819">Data::ElementMap::find()</a>, <a class="el" href="../../d7/d7a/ElementMap_8cpp_source.html#l01298">Data::ElementMap::getAll()</a>, and <a class="el" href="../../d2/d2c/StringHasher_8cpp_source.html#l00301">App::StringHasher::getID()</a>.</p>

</div>
</div>
<a id="a334c76c8f2ac9ea331796454310ca9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a334c76c8f2ac9ea331796454310ca9ff">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Data::IndexedName::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create and return a new std::string with this name in it.</p>
<dl class="section return"><dt>Returns</dt><dd>A newly-created string with the <a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a> in it (e.g. "EDGE42") </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00192">192</a> of file <a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d5/d32/SketchObject_8cpp_source.html#l11646">Sketcher::SketchObject::convertSubName()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a33bf407e2a9279f62af6225a0074def2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33bf407e2a9279f62af6225a0074def2">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/deb/classData_1_1IndexedName.html">IndexedName</a> &amp;&#160;</td>
          <td class="paramname"><em>indexedName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An indexedName is represented as the simple concatenation of the name and its index, e.g. "EDGE1" or "FACE42". </p>

<p class="definition">Definition at line <a class="el" href="../../d2/dd9/IndexedName_8h_source.html#l00201">201</a> of file <a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="../../d2/dd9/IndexedName_8h_source.html">IndexedName.h</a></li>
<li><a class="el" href="../../db/da9/IndexedName_8cpp_source.html">IndexedName.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
